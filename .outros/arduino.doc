/* esp_dht_final.ino
   - Leitura DHT11 com retries
   - Exponhe /status (JSON) otimizado (sem String)
   - Exponhe /config?temp=...&hum=... (persistidos em EEPROM)
   - Só faz POST para serverURL quando variação >= thresholds
   - WiFiManager para config. de WiFi (SSID/Senha)
   - WiFiManager para config. de Parâmetro (serverURL)
   - mDNS para hostname amigável (http://esp-dht.local)
   - Endpoint /resetwifi para forçar reconfiguração via software
*/

#include <ESP8266WiFi.h>
#include <WiFiManager.h>        // Para configuração fácil do WiFi
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>        // Para http://esp-dht.local
#include <DHT.h>
#include <EEPROM.h>

// ---------- CONFIG ----------
// O URL do servidor agora é uma variável que o WiFiManager pode preencher
char serverURL[128] = "http://192.168.1.100/Arduino/api/salvar_dht.php";

// --- O PINO DE RESET FOI REMOVIDO ---
// #define WIFI_RESET_PIN D7 // (GPIO13) <-- REMOVIDO

#define DHTPIN 4        // GPIO4 - D2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const unsigned long SEND_INTERVAL = 2000UL; // intervalo entre leituras (ms), >=2000 recomendado
const int DHT_MAX_RETRIES = 3;

// EEPROM
#define EEPROM_SIZE 64
const int ADDR_MAGIC = 0;
const int ADDR_TEMP  = 4; // float (4 bytes)
const int ADDR_HUM   = 8; // float (4 bytes)
const uint8_t EEPROM_MAGIC = 0xA5;

// thresholds (inicializados, podem ser sobrescritos pela EEPROM)
float tempThreshold = 2.0f;  // °C
float humThreshold  = 10.0f; // %

ESP8266WebServer server(80);

// ---------- ESTADO ----------
unsigned long lastSend = 0;
int failCount = 0;

float latestTemp = NAN, latestHum = NAN;
float lastSentTemp = NAN, lastSentHum = NAN;

void printNetworkInfo() {
  Serial.println("=== Rede ===");
  Serial.print("SSID: "); Serial.println(WiFi.SSID());
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
  Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
  Serial.println("============");
}

void saveThresholdsToEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.write(ADDR_MAGIC, EEPROM_MAGIC);
  union { float f; uint8_t b[4]; } u;
  u.f = tempThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_TEMP + i, u.b[i]);
  u.f = humThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_HUM + i, u.b[i]);
  EEPROM.commit();
  EEPROM.end();
  Serial.printf("Thresholds salvos na EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
}

void loadThresholdsFromEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  uint8_t magic = EEPROM.read(ADDR_MAGIC);
  if (magic == EEPROM_MAGIC) {
    union { float f; uint8_t b[4]; } u;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_TEMP + i);
    tempThreshold = u.f;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_HUM + i);
    humThreshold = u.f;
    Serial.printf("Thresholds carregados da EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
  } else {
    Serial.println("EEPROM vazia — usando thresholds padrao e salvando.");
    saveThresholdsToEEPROM();
  }
  EEPROM.end();
}


bool readDHT(float &temp, float &hum) {
  for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
    temp = dht.readTemperature();
    hum  = dht.readHumidity();
    if (!isnan(temp) && !isnan(hum)) return true;

    Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                  attempt, DHT_MAX_RETRIES,
                  isnan(temp) ? "NaN" : String(temp,2).c_str(),
                  isnan(hum)  ? "NaN" : String(hum,2).c_str()
                 );
    delay(2000); // DHT needs ~2s between reads
  }
  return false;
}

bool sendToServer(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado: sem conexão WiFi");
    return false;
  }

  WiFiClient client;
  HTTPClient http;
  
  if (!http.begin(client, serverURL)) { 
    Serial.println("HTTP.begin falhou");
    return false;
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  
  char postBody[64];
  snprintf(postBody, sizeof(postBody), "temp=%.2f&hum=%.2f", temp, hum);
  
  Serial.print("POST >> "); Serial.println(postBody);
  Serial.print("Para >> "); Serial.println(serverURL); 

  int httpCode = http.POST(postBody);
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
    String payload = http.getString();
    Serial.print("Resposta servidor: "); Serial.println(payload);
    http.end();
    return (httpCode >= 200 && httpCode < 300);
  } else {
    Serial.print("Erro na requisição POST: ");
    Serial.println(http.errorToString(httpCode));
    http.end();
    return false;
  }
}

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println("=== ESP8266 DHT11 - Iniciando (condicional) ===");
  dht.begin();

  // --- Conexão WiFi com WiFiManager ---
  WiFiManager wifiManager; // Declaramos o manager aqui

  // --- (BLOCO DE RESET FÍSICO REMOVIDO) ---
  // A verificação do pino D7 foi removida.

  // 1. Crie o parâmetro customizado
  WiFiManagerParameter custom_server_url("server_url", "URL do Servidor API", serverURL, 128);

  // 2. Adicione o parâmetro ao gerenciador
  wifiManager.addParameter(&custom_server_url);

  // Inicia o portal de configuração
  if (!wifiManager.autoConnect("AutoConnectAP", "password")) {
    Serial.println("Falha ao conectar e o tempo de config expirou");
    delay(3000);
    ESP.restart(); 
    delay(5000);
  }
  
  // Se chegou aqui, é porque conectou!
  Serial.println("WiFi conectado com sucesso!");
  printNetworkInfo(); // Mostra o IP no terminal!

  // --- (INÍCIO NOVA CONFIG mDNS) ---
  Serial.println("Iniciando mDNS (http://esp-dht.local)");
  if (!MDNS.begin("esp-dht")) { 
    Serial.println("Erro ao iniciar mDNS!");
  } else {
    MDNS.addService("http", "tcp", 80);
    Serial.println("mDNS iniciado. Acesse em: http://esp-dht.local");
  }
  // --- (FIM NOVA CONFIG mDNS) ---


  // 3. ATUALIZA nossa variável global 'serverURL' com o valor que o usuário digitou
  strcpy(serverURL, custom_server_url.getValue());

  Serial.println("--- Configurações Customizadas ---");
  Serial.print("URL do Servidor: ");
  Serial.println(serverURL); // Mostra o URL que foi salvo
  Serial.println("---------------------------------");
  
  // EEPROM thresholds
  loadThresholdsFromEEPROM();

  // server endpoints
  
  // --- ENDPOINT /status OTIMIZADO (sem String) ---
  server.on("/status", HTTP_GET, []() {
    char buffer[192]; 
    snprintf(buffer, sizeof(buffer),
      "{\"status\":\"ok\",\"temperatura\":%.2f,\"umidade\":%.2f,\"saved_temp\":%.2f,\"saved_hum\":%.2f}",
      isnan(latestTemp) ? 0.0 : latestTemp,
      isnan(latestHum)  ? 0.0 : latestHum,
      isnan(lastSentTemp) ? 0.0 : lastSentTemp,
      isnan(lastSentHum)  ? 0.0 : lastSentHum
    );
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", buffer); 
  });
  
  // config: /config?temp=2.0&hum=10.0
  server.on("/config", HTTP_GET, []() {
    bool updated = false;
    if (server.hasArg("temp")) {
      tempThreshold = server.arg("temp").toFloat();
      updated = true;
    }
    if (server.hasArg("hum")) {
      humThreshold = server.arg("hum").toFloat();
      updated = true;
    }
    if (updated) {
      saveThresholdsToEEPROM();
    }
    String js = "{\"status\":\"ok\",\"tempThreshold\":" + String(tempThreshold,2) + ",\"humThreshold\":" + String(humThreshold,2) + "}";
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  server.on("/ping", HTTP_GET, []() {
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "text/plain", "pong");
  });

  // --- NOVO ENDPOINT DE RESET VIA SOFTWARE ---
  server.on("/resetwifi", HTTP_GET, []() {
    Serial.println("Recebida solicitação /resetwifi...");
    
    // 1. Envia a resposta ao usuário IMEDIATAMENTE.
    server.send(200, "text/html", 
      "<h1>Configuracoes de WiFi limpas!</h1>"
      "<p>O ESP vai reiniciar em 3 segundos e criar o portal 'AutoConnectAP'.</p>"
      "<p>Conecte-se a essa rede para reconfigurar.</p>");
    
    // 2. Dá um pequeno delay para a resposta ser enviada
    delay(3000); 

    // 3. Cria uma instância temporária SÓ para limpar as configs
    WiFiManager wifiManager; 
    wifiManager.resetSettings();
    
    Serial.println("Configurações limpas. Reiniciando agora...");
    
    // 4. Reinicia o ESP
    ESP.restart();
  });


  server.begin();
  Serial.println("HTTP server iniciado (endpoints: /status, /config, /resetwifi)");
}

void loop() {
  unsigned long now = millis();
  server.handleClient();
  MDNS.update(); // Mantém o mDNS funcionando

  if (now - lastSend >= SEND_INTERVAL) {
    lastSend = now;

    float temp = NAN, hum = NAN;
    if (!readDHT(temp, hum)) {
      Serial.println("Falha: não foi possível ler DHT após retries.");
      failCount++;
      return;
    }

    latestTemp = temp;
    latestHum  = hum;

    Serial.printf("Leitura -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);

    // decide se grava no DB
    bool shouldSend = false;
    if (isnan(lastSentTemp) || isnan(lastSentHum)) {
      shouldSend = true; // primeira vez salva
      Serial.println("Primeiro envio: gravando no DB.");
    } else {
      float dt = fabs(temp - lastSentTemp);
      float dh = fabs(hum  - lastSentHum);
      Serial.printf("Diferença p/ ultimo salvo -> dT=%.2f, dH=%.2f (thresholds: %.2f °C / %.2f %%)\n", dt, dh, tempThreshold, humThreshold);
      if (dt >= tempThreshold || dh >= humThreshold) {
        shouldSend = true;
        Serial.println("Diferença maior que threshold: gravando no DB.");
      } else {
        Serial.println("Diferença menor que threshold: NÃO gravar no DB (apenas /status).");
      }
    }

    if (shouldSend) {
      // A função sendToServer() agora usa o serverURL que o usuário configurou
      bool ok = sendToServer(temp, hum); 
      if (ok) {
        lastSentTemp = temp;
        lastSentHum  = hum;
        Serial.println("Envio OK e atualizado lastSent.");
        failCount = 0;
      } else {
        Serial.println("Envio falhou.");
        failCount++;
      }
    }
  }

  delay(10);
}