/* esp_dht_conditional_wifimgr.ino
   - Leitura DHT11 com retries
   - Exponhe /status (JSON) com retries e otimizado (sem String)
   - Exponhe /config?temp=...&hum=... (persistidos em EEPROM)
   - Só faz POST para serverURL quando variação >= thresholds
   - WiFiManager para configuração de WiFi via Portal Cativo
*/

#include <ESP8266WiFi.h>
#include <WiFiManager.h>        // Para configuração fácil do WiFi
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <DHT.h>
#include <EEPROM.h>

// ---------- CONFIG ----------
// O SSID e Senha são configurados pelo WiFiManager
// const char* ssid = "eduardo"; // <-- REMOVIDO
// const char* password = "eduardods"; // <-- REMOVIDO

// servidor que salva no DB (salvar_dht.php)
const char* serverURL = "http://192.168.1.107/Arduino/api/salvar_dht.php";

#define DHTPIN 4        // GPIO4 - D2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const unsigned long SEND_INTERVAL = 2000UL; // intervalo entre leituras (ms), >=2000 recomendado
// const unsigned long WIFI_RECONNECT_INTERVAL = 10000UL; // Não é mais usado pelo WiFiManager
const int DHT_MAX_RETRIES = 3;

// EEPROM
#define EEPROM_SIZE 64
const int ADDR_MAGIC = 0;
const int ADDR_TEMP  = 4; // float (4 bytes)
const int ADDR_HUM   = 8; // float (4 bytes)
const uint8_t EEPROM_MAGIC = 0xA5;

// thresholds (inicializados, podem ser sobrescritos pela EEPROM)
float tempThreshold = 2.0f;  // °C
float humThreshold  = 10.0f; // %

ESP8266WebServer server(80);

// ---------- ESTADO ----------
unsigned long lastSend = 0;
// unsigned long lastWifiTry = 0; // Não é mais usado
int failCount = 0;

float latestTemp = NAN, latestHum = NAN;
float lastSentTemp = NAN, lastSentHum = NAN;

void printNetworkInfo() {
  Serial.println("=== Rede ===");
  Serial.print("SSID: "); Serial.println(WiFi.SSID());
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
  Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
  Serial.println("============");
}

void saveThresholdsToEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.write(ADDR_MAGIC, EEPROM_MAGIC);
  union { float f; uint8_t b[4]; } u;
  u.f = tempThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_TEMP + i, u.b[i]);
  u.f = humThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_HUM + i, u.b[i]);
  EEPROM.commit();
  EEPROM.end();
  Serial.printf("Thresholds salvos na EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
}

void loadThresholdsFromEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  uint8_t magic = EEPROM.read(ADDR_MAGIC);
  if (magic == EEPROM_MAGIC) {
    union { float f; uint8_t b[4]; } u;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_TEMP + i);
    tempThreshold = u.f;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_HUM + i);
    humThreshold = u.f;
    Serial.printf("Thresholds carregados da EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
  } else {
    Serial.println("EEPROM vazia — usando thresholds padrao e salvando.");
    saveThresholdsToEEPROM();
  }
  EEPROM.end();
}

// A função ensureWiFiConnected() foi removida, 
// pois o WiFiManager cuida da conexão inicial 
// e o ESP SDK tenta reconectar automaticamente se cair.

bool readDHT(float &temp, float &hum) {
  for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
    temp = dht.readTemperature();
    hum  = dht.readHumidity();
    if (!isnan(temp) && !isnan(hum)) return true;

    Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                  attempt, DHT_MAX_RETRIES,
                  isnan(temp) ? "NaN" : String(temp,2).c_str(),
                  isnan(hum)  ? "NaN" : String(hum,2).c_str()
                 );
    delay(2000); // DHT needs ~2s between reads
  }
  return false;
}

bool sendToServer(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado: sem conexão WiFi");
    return false;
  }

  WiFiClient client;
  HTTPClient http;
  if (!http.begin(client, serverURL)) {
    Serial.println("HTTP.begin falhou");
    return false;
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  
  // Otimização aqui também: usar buffer para o body do POST
  char postBody[64];
  snprintf(postBody, sizeof(postBody), "temp=%.2f&hum=%.2f", temp, hum);
  
  Serial.print("POST >> "); Serial.println(postBody);

  int httpCode = http.POST(postBody); // Envia o buffer
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
    String payload = http.getString();
    Serial.print("Resposta servidor: "); Serial.println(payload);
    http.end();
    return (httpCode >= 200 && httpCode < 300);
  } else {
    Serial.print("Erro na requisição POST: ");
    Serial.println(http.errorToString(httpCode));
    http.end();
    return false;
  }
}

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println("=== ESP8266 DHT11 - Iniciando (condicional) ===");
  dht.begin();

  // --- Conexão WiFi com WiFiManager ---
  WiFiManager wifiManager;

  // Descomente a linha abaixo para limpar as credenciais salvas (para testes)
  // wifiManager.resetSettings(); 

  // Tenta conectar. Se não conseguir, inicia o portal de configuração
  // O "AutoConnect" cria um AP (Access Point) com o nome "AutoConnectAP"
  // e uma senha "password"
  // Você pode mudar isso para:
  // if (!wifiManager.autoConnect("ESP-DHT11-Config")) {
  if (!wifiManager.autoConnect("AutoConnectAP", "password")) {
    Serial.println("Falha ao conectar e o tempo de config expirou");
    delay(3000);
    ESP.restart(); // Reinicia para tentar de novo
    delay(5000);
  }
  
  // Se chegou aqui, é porque conectou!
  Serial.println("WiFi conectado com sucesso!");
  printNetworkInfo(); // Mostra o IP no terminal!

  // EEPROM thresholds
  loadThresholdsFromEEPROM();

  // server endpoints
  
  // --- ENDPOINT /status OTIMIZADO (sem String) ---
  server.on("/status", HTTP_GET, []() {
    // Use um buffer C-style (192 bytes é mais que suficiente aqui)
    char buffer[192]; 
    
    // Usamos snprintf para formatar a string de forma segura e eficiente
    snprintf(buffer, sizeof(buffer),
      "{\"status\":\"ok\",\"temperatura\":%.2f,\"umidade\":%.2f,\"saved_temp\":%.2f,\"saved_hum\":%.2f}",
      isnan(latestTemp) ? 0.0 : latestTemp,
      isnan(latestHum)  ? 0.0 : latestHum,
      isnan(lastSentTemp) ? 0.0 : lastSentTemp,
      isnan(lastSentHum)  ? 0.0 : lastSentHum
    );
  
    server.sendHeader("Access-Control-Allow-Origin", "*");
    // Envia o buffer diretamente
    server.send(200, "application/json", buffer); 
  });
  
  // config: /config?temp=2.0&hum=10.0
  server.on("/config", HTTP_GET, []() {
    bool updated = false;
    String msg = "";
    if (server.hasArg("temp")) {
      float t = server.arg("temp").toFloat();
      tempThreshold = t;
      updated = true;
      msg += "temp=" + String(t,2) + " ";
    }
    if (server.hasArg("hum")) {
      float h = server.arg("hum").toFloat();
      humThreshold = h;
      updated = true;
      msg += "hum=" + String(h,2) + " ";
    }
    if (updated) {
      saveThresholdsToEEPROM();
    }
    
    // Aqui ainda podemos usar String para otimizar tempo, 
    // pois é uma requisição rara (configuração) e não em loop.
    String js = "{\"status\":\"ok\",\"tempThreshold\":" + String(tempThreshold,2) + ",\"humThreshold\":" + String(humThreshold,2) + "}";
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  server.on("/ping", HTTP_GET, []() {
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "text/plain", "pong");
  });

  server.begin();
  Serial.println("HTTP server iniciado (endpoints: /status, /config)");
}

void loop() {
  unsigned long now = millis();
  server.handleClient();
  // ensureWiFiConnected(); // <-- REMOVIDO

  if (now - lastSend >= SEND_INTERVAL) {
    lastSend = now;

    float temp = NAN, hum = NAN;
    if (!readDHT(temp, hum)) {
      Serial.println("Falha: não foi possível ler DHT após retries.");
      failCount++;
      return;
    }

    latestTemp = temp;
    latestHum  = hum;

    Serial.printf("Leitura -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);

    // decide se grava no DB
    bool shouldSend = false;
    if (isnan(lastSentTemp) || isnan(lastSentHum)) {
      shouldSend = true; // primeira vez salva
      Serial.println("Primeiro envio: gravando no DB.");
    } else {
      float dt = fabs(temp - lastSentTemp);
      float dh = fabs(hum  - lastSentHum);
      Serial.printf("Diferença p/ ultimo salvo -> dT=%.2f, dH=%.2f (thresholds: %.2f °C / %.2f %%)\n", dt, dh, tempThreshold, humThreshold);
      if (dt >= tempThreshold || dh >= humThreshold) {
        shouldSend = true;
        Serial.println("Diferença maior que threshold: gravando no DB.");
      } else {
        Serial.println("Diferença menor que threshold: NÃO gravar no DB (apenas /status).");
      }
    }

    if (shouldSend) {
      bool ok = sendToServer(temp, hum);
      if (ok) {
        lastSentTemp = temp;
        lastSentHum  = hum;
        Serial.println("Envio OK e atualizado lastSent.");
        failCount = 0;
      } else {
        Serial.println("Envio falhou.");
        failCount++;
      }
    }
  }

  delay(10);
}