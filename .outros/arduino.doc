/* esp_dht_conditional.ino
   - Leitura DHT11 com retries
   - Exponhe /status (JSON) com última leitura
   - Exponhe /config?temp=...&hum=... para ajustar thresholds (persistidos em EEPROM)
   - Só faz POST para serverURL quando variação >= thresholds
   - Reconnect WiFi não-bloqueante
*/

#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <DHT.h>
#include <EEPROM.h>

// ---------- CONFIG ----------
const char* ssid = "eduardo";
const char* password = "eduardods";

// servidor que salva no DB (salvar_dht.php)
const char* serverURL = "http://192.168.137.1/Arduino/api/salvar_dht.php";

#define DHTPIN 4        // GPIO4 - D2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const unsigned long SEND_INTERVAL = 2000UL; // intervalo entre leituras (ms), >=2000 recomendado
const unsigned long WIFI_RECONNECT_INTERVAL = 10000UL;
const int DHT_MAX_RETRIES = 3;

// EEPROM
#define EEPROM_SIZE 64
const int ADDR_MAGIC = 0;
const int ADDR_TEMP  = 4; // float (4 bytes)
const int ADDR_HUM   = 8; // float (4 bytes)
const uint8_t EEPROM_MAGIC = 0xA5;

// thresholds (inicializados, podem ser sobrescritos pela EEPROM)
float tempThreshold = 2.0f;  // °C
float humThreshold  = 10.0f; // %

ESP8266WebServer server(80);

// ---------- ESTADO ----------
unsigned long lastSend = 0;
unsigned long lastWifiTry = 0;
int failCount = 0;

float latestTemp = NAN, latestHum = NAN;
float lastSentTemp = NAN, lastSentHum = NAN;

void printNetworkInfo() {
  Serial.println("=== Rede ===");
  Serial.print("SSID: "); Serial.println(WiFi.SSID());
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
  Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
  Serial.println("============");
}

void saveThresholdsToEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.write(ADDR_MAGIC, EEPROM_MAGIC);
  union { float f; uint8_t b[4]; } u;
  u.f = tempThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_TEMP + i, u.b[i]);
  u.f = humThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_HUM + i, u.b[i]);
  EEPROM.commit();
  EEPROM.end();
  Serial.printf("Thresholds salvos na EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
}

void loadThresholdsFromEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  uint8_t magic = EEPROM.read(ADDR_MAGIC);
  if (magic == EEPROM_MAGIC) {
    union { float f; uint8_t b[4]; } u;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_TEMP + i);
    tempThreshold = u.f;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_HUM + i);
    humThreshold = u.f;
    Serial.printf("Thresholds carregados da EEPROM: temp=%.2f hum=%.2f\n", tempThreshold, humThreshold);
  } else {
    Serial.println("EEPROM vazia — usando thresholds padrao e salvando.");
    saveThresholdsToEEPROM();
  }
  EEPROM.end();
}

void ensureWiFiConnected() {
  if (WiFi.status() == WL_CONNECTED) return;
  unsigned long now = millis();
  if (now - lastWifiTry < WIFI_RECONNECT_INTERVAL) return;
  lastWifiTry = now;

  Serial.println("WiFi desconectado — tentando reconectar...");
  WiFi.disconnect();
  WiFi.begin(ssid, password);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 5000) {
    delay(250);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Reconectado ao WiFi!");
    printNetworkInfo();
  } else {
    Serial.println("Falha ao reconectar WiFi desta vez.");
  }
}

bool readDHT(float &temp, float &hum) {
  for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
    temp = dht.readTemperature();
    hum  = dht.readHumidity();
    if (!isnan(temp) && !isnan(hum)) return true;

    Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                  attempt, DHT_MAX_RETRIES,
                  isnan(temp) ? "NaN" : String(temp,2).c_str(),
                  isnan(hum)  ? "NaN" : String(hum,2).c_str()
                 );
    delay(2000); // DHT needs ~2s between reads
  }
  return false;
}

bool sendToServer(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado: sem conexão WiFi");
    return false;
  }

  WiFiClient client;
  HTTPClient http;
  if (!http.begin(client, serverURL)) {
    Serial.println("HTTP.begin falhou");
    return false;
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  String body = "temp=" + String(temp, 2) + "&hum=" + String(hum, 2);
  Serial.print("POST >> "); Serial.println(body);

  int httpCode = http.POST(body);
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
    String payload = http.getString();
    Serial.print("Resposta servidor: "); Serial.println(payload);
    http.end();
    return (httpCode >= 200 && httpCode < 300);
  } else {
    Serial.print("Erro na requisição POST: ");
    Serial.println(http.errorToString(httpCode));
    http.end();
    return false;
  }
}

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println("=== ESP8266 DHT11 - Iniciando (condicional) ===");
  dht.begin();

  // WiFi (não-bloqueante)
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Conectando WiFi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi conectado!");
    printNetworkInfo();
  } else {
    Serial.println("WiFi NÃO conectado (iniciando sem bloqueio). Tentarei reconectar depois.");
  }

  // EEPROM thresholds
  loadThresholdsFromEEPROM();

  // server endpoints
  server.on("/status", HTTP_GET, []() {
    String js = "{";
    js += "\"status\":\"ok\",";
    js += "\"temperatura\":" + String(isnan(latestTemp) ? 0.0 : latestTemp, 2) + ",";
    js += "\"umidade\":"     + String(isnan(latestHum)  ? 0.0 : latestHum, 2)  + ",";
    js += "\"saved_temp\":"  + String(isnan(lastSentTemp) ? 0.0 : lastSentTemp, 2) + ",";
    js += "\"saved_hum\":"   + String(isnan(lastSentHum)  ? 0.0 : lastSentHum, 2);
    js += "}";
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  // config: /config?temp=2.0&hum=10.0
  server.on("/config", HTTP_GET, []() {
    bool updated = false;
    String msg = "";
    if (server.hasArg("temp")) {
      float t = server.arg("temp").toFloat();
      tempThreshold = t;
      updated = true;
      msg += "temp=" + String(t,2) + " ";
    }
    if (server.hasArg("hum")) {
      float h = server.arg("hum").toFloat();
      humThreshold = h;
      updated = true;
      msg += "hum=" + String(h,2) + " ";
    }
    if (updated) {
      saveThresholdsToEEPROM();
    }
    String js = "{\"status\":\"ok\",\"tempThreshold\":" + String(tempThreshold,2) + ",\"humThreshold\":" + String(humThreshold,2) + "}";
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  server.on("/ping", HTTP_GET, []() {
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "text/plain", "pong");
  });

  server.begin();
  Serial.println("HTTP server iniciado (endpoints: /status, /config)");
}

void loop() {
  unsigned long now = millis();
  server.handleClient();
  ensureWiFiConnected();

  if (now - lastSend >= SEND_INTERVAL) {
    lastSend = now;

    float temp = NAN, hum = NAN;
    if (!readDHT(temp, hum)) {
      Serial.println("Falha: não foi possível ler DHT após retries.");
      failCount++;
      return;
    }

    latestTemp = temp;
    latestHum  = hum;

    Serial.printf("Leitura -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);

    // decide se grava no DB
    bool shouldSend = false;
    if (isnan(lastSentTemp) || isnan(lastSentHum)) {
      shouldSend = true; // primeira vez salva
      Serial.println("Primeiro envio: gravando no DB.");
    } else {
      float dt = fabs(temp - lastSentTemp);
      float dh = fabs(hum  - lastSentHum);
      Serial.printf("Diferença p/ ultimo salvo -> dT=%.2f, dH=%.2f (thresholds: %.2f °C / %.2f %%)\n", dt, dh, tempThreshold, humThreshold);
      if (dt >= tempThreshold || dh >= humThreshold) {
        shouldSend = true;
        Serial.println("Diferença maior que threshold: gravando no DB.");
      } else {
        Serial.println("Diferença menor que threshold: NÃO gravar no DB (apenas /status).");
      }
    }

    if (shouldSend) {
      bool ok = sendToServer(temp, hum);
      if (ok) {
        lastSentTemp = temp;
        lastSentHum  = hum;
        Serial.println("Envio OK e atualizado lastSent.");
        failCount = 0;
      } else {
        Serial.println("Envio falhou.");
        failCount++;
      }
    }
  }

  delay(10);
}
