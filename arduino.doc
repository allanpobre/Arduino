  /* Sketch ESP8266 + DHT11 robusto
    - Leitura com retries
    - Reconnect WiFi não-bloqueante (tentativas periódicas)
    - Envio via HTTP POST (application/x-www-form-urlencoded)
    - Logs detalhados
    Ajuste ssid/password/serverURL conforme sua rede/servidor.
  */

  #include <ESP8266WiFi.h>
  #include <ESP8266HTTPClient.h>
  #include <DHT.h>

  // -------------- CONFIG --------------
  const char* ssid = "eduardo";
  const char* password = "eduardods";
  const char* serverURL = "http://192.168.137.1/Arduino/salvar_dht.php"; // ajuste para seu servidor (com /Arduino/...)
  #define DHTPIN 4        // GPIO4 - corresponde ao D2 em muitos módulos NodeMCU
  #define DHTTYPE DHT11   // DHT11 ou DHT22
  DHT dht(DHTPIN, DHTTYPE);

  const unsigned long SEND_INTERVAL = 5000UL; // intervalo entre envios (ms) - DHT mínimo ~2000ms
  const unsigned long WIFI_RECONNECT_INTERVAL = 10000UL; // intervalo entre tentativas de reconexão WiFi (ms)
  const int DHT_MAX_RETRIES = 3; // quantas tentativas fazer se leitura falhar

  // -------------- ESTADO --------------
  unsigned long lastSend = 0;
  unsigned long lastWifiTry = 0;
  int failCount = 0;

  void setup() {
    Serial.begin(115200);
    delay(50);
    Serial.println();
    Serial.println("=== ESP8266 DHT11 - Iniciando ===");
    Serial.print("DHT pin: "); Serial.println(DHTPIN);
    Serial.print("Intervalo envio: "); Serial.print(SEND_INTERVAL); Serial.println(" ms");

    dht.begin();

    // inicia conexão WiFi (não bloqueante longamente: teremos tentativas periódicas)
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.print("Conectando WiFi");
    unsigned long start = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) {
      delay(300);
      Serial.print(".");
    }
    Serial.println();
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("WiFi conectado!");
      printNetworkInfo();
    } else {
      Serial.println("WiFi NÃO conectado (iniciando sem bloqueio). Tentarei reconectar depois.");
    }
  }

  void printNetworkInfo() {
    Serial.println("=== Rede ===");
    Serial.print("SSID: "); Serial.println(WiFi.SSID());
    Serial.print("IP: "); Serial.println(WiFi.localIP());
    Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
    Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
    Serial.println("============");
  }

  void ensureWiFiConnected() {
    if (WiFi.status() == WL_CONNECTED) return;

    unsigned long now = millis();
    if (now - lastWifiTry < WIFI_RECONNECT_INTERVAL) return; // aguarda próximo intervalo
    lastWifiTry = now;

    Serial.println("WiFi desconectado — tentando reconectar...");
    WiFi.disconnect();
    WiFi.begin(ssid, password);

    unsigned long t0 = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - t0 < 5000) {
      delay(250);
      Serial.print(".");
    }
    Serial.println();
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("Reconectado ao WiFi!");
      printNetworkInfo();
    } else {
      Serial.println("Falha ao reconectar WiFi desta vez.");
    }
  }

  /*
    Tenta ler o sensor DHT, com retries.
    Retorna true se leitura bem-sucedida; valores preenchidos em temps/hum.
  */
  bool readDHT(float &temp, float &hum) {
    for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
      temp = dht.readTemperature();
      hum  = dht.readHumidity();

      if (!isnan(temp) && !isnan(hum)) {
        return true;
      }

      Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                    attempt, DHT_MAX_RETRIES,
                    isnan(temp) ? "NaN" : String(temp,2).c_str(),
                    isnan(hum)  ? "NaN" : String(hum,2).c_str()
                  );

      // DHT precisa de ~2s entre leituras; aguarda antes da próxima tentativa
      delay(2000);
    }
    return false;
  }

  /*
    Envia via HTTP POST (application/x-www-form-urlencoded).
    Retorna true se HTTP code 200..299.
  */
  bool sendToServer(float temp, float hum) {
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("Não enviado: sem conexão WiFi");
      return false;
    }

    WiFiClient client;
    HTTPClient http;

    // begin com URL (HTTP)
    if (!http.begin(client, serverURL)) {
      Serial.println("HTTP.begin falhou");
      return false;
    }

    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    // payload: temp e hum (aceito também no PHP da versão anterior)
    String body = "temp=" + String(temp, 2) + "&hum=" + String(hum, 2);
    Serial.print("POST >> "); Serial.println(body);

    int httpCode = http.POST(body);
    if (httpCode > 0) {
      Serial.print("HTTP code: "); Serial.println(httpCode);
      String payload = http.getString();
      Serial.print("Resposta servidor: "); Serial.println(payload);
      http.end();
      return (httpCode >= 200 && httpCode < 300);
    } else {
      Serial.print("Erro na requisição POST: ");
      Serial.println(http.errorToString(httpCode));
      http.end();
      return false;
    }
  }

  void loop() {
    unsigned long now = millis();

    // tenta manter WiFi conectado (sem bloquear sempre)
    ensureWiFiConnected();

    if (now - lastSend >= SEND_INTERVAL) {
      lastSend = now;

      float temp = NAN, hum = NAN;
      if (!readDHT(temp, hum)) {
        Serial.println("Falha: não foi possível ler DHT após retries.");
        failCount++;
        return;
      }

      Serial.printf("Leitura OK -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);

      bool ok = sendToServer(temp, hum);
      if (ok) {
        Serial.println("Envio OK");
        failCount = 0;
      } else {
        Serial.println("Envio falhou");
        failCount++;
      }
    }

    // opcional: se falhas contínuas grandes, pode reiniciar para recuperar (descomente se desejar)
    // if (failCount >= 10) { Serial.println("Muitas falhas, reiniciando..."); ESP.restart(); }

    // pequeno delay para liberar CPU (não bloquear demais)
    delay(10);
  }
