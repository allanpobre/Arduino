/* Sketch ESP8266 + DHT11
   - Envia ao servidor (salvar_dht.php) apenas quando houver mudança acima de thresholds
   - Sempre expõe /status (JSON) com a última leitura lida para que a UI atualize o gráfico
   - Reconnect WiFi não-bloqueante
   - Leitura com retries
*/

#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <DHT.h>

// ---------- CONFIG ----------
const char* ssid = "eduardo";
const char* password = "eduardods";
const char* serverURL = "http://192.168.137.1/Arduino/salvar_dht.php"; // where to POST when storing in DB

#define DHTPIN 4        // GPIO4 (D2)
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const unsigned long SEND_INTERVAL = 5000UL; // intervalo entre leituras
const unsigned long WIFI_RECONNECT_INTERVAL = 10000UL;
const int DHT_MAX_RETRIES = 3;

// thresholds para decidir gravação no DB
const float TEMP_THRESHOLD = 2.0f;   // graus Celsius
const float HUM_THRESHOLD  = 10.0f;  // percentual

// ---------- ESTADO ----------
unsigned long lastSend = 0;
unsigned long lastWifiTry = 0;
int failCount = 0;

// valores que representam:
// latest -> última leitura (sempre atualizada, usada pelo /status para UI)
// lastSent -> último valor QUE FOI gravado no DB (usado para comparar com nova leitura)
float latestTemp = NAN, latestHum = NAN;
float lastSentTemp = NAN, lastSentHum = NAN;

ESP8266WebServer server(80);

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println("=== ESP8266 DHT11 - Iniciando (com gravação condicional) ===");

  dht.begin();

  // WiFi (não-bloqueante longo)
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Conectando WiFi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi conectado!");
    printNetworkInfo();
  } else {
    Serial.println("WiFi NÃO conectado (iniciando sem bloqueio). Tentarei reconectar depois.");
  }

  // start simple web server route /status (CORS)
  server.on("/status", HTTP_GET, [](){
    String js = "{";
    js += "\"status\":\"ok\",";
    js += "\"temperatura\":" + String(isnan(latestTemp) ? 0.0 : latestTemp, 2) + ",";
    js += "\"umidade\":" + String(isnan(latestHum) ? 0.0 : latestHum, 2) + ",";
    js += "\"saved_temp\":" + String(isnan(lastSentTemp) ? 0.0 : lastSentTemp, 2) + ",";
    js += "\"saved_hum\":" + String(isnan(lastSentHum) ? 0.0 : lastSentHum, 2);
    js += "}";
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  // health / ping
  server.on("/ping", HTTP_GET, [](){
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "text/plain", "pong");
  });

  server.begin();
  Serial.println("HTTP server iniciado (endpoint /status)");
}

void printNetworkInfo() {
  Serial.println("=== Rede ===");
  Serial.print("SSID: "); Serial.println(WiFi.SSID());
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
  Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
  Serial.println("============");
}

void ensureWiFiConnected() {
  if (WiFi.status() == WL_CONNECTED) return;

  unsigned long now = millis();
  if (now - lastWifiTry < WIFI_RECONNECT_INTERVAL) return;
  lastWifiTry = now;

  Serial.println("WiFi desconectado — tentando reconectar...");
  WiFi.disconnect();
  WiFi.begin(ssid, password);

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 5000) {
    delay(250);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Reconectado ao WiFi!");
    printNetworkInfo();
  } else {
    Serial.println("Falha ao reconectar WiFi desta vez.");
  }
}

/*
  leitura DHT com retries
*/
bool readDHT(float &temp, float &hum) {
  for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
    temp = dht.readTemperature();
    hum  = dht.readHumidity();

    if (!isnan(temp) && !isnan(hum)) {
      return true;
    }

    Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                  attempt, DHT_MAX_RETRIES,
                  isnan(temp) ? "NaN" : String(temp,2).c_str(),
                  isnan(hum)  ? "NaN" : String(hum,2).c_str()
                );
    delay(2000);
  }
  return false;
}

/*
  envia via HTTP POST (application/x-www-form-urlencoded).
  retorna true se HTTP code 200..299
*/
bool sendToServer(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado: sem conexão WiFi");
    return false;
  }

  WiFiClient client;
  HTTPClient http;

  if (!http.begin(client, serverURL)) {
    Serial.println("HTTP.begin falhou");
    return false;
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  String body = "temp=" + String(temp, 2) + "&hum=" + String(hum, 2);
  Serial.print("POST >> "); Serial.println(body);

  int httpCode = http.POST(body);
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
    String payload = http.getString();
    Serial.print("Resposta servidor: "); Serial.println(payload);
    http.end();
    return (httpCode >= 200 && httpCode < 300);
  } else {
    Serial.print("Erro na requisição POST: ");
    Serial.println(http.errorToString(httpCode));
    http.end();
    return false;
  }
}

void loop() {
  unsigned long now = millis();
  server.handleClient(); // responde /status sem bloquear

  // tenta manter WiFi conectado
  ensureWiFiConnected();

  if (now - lastSend >= SEND_INTERVAL) {
    lastSend = now;

    float temp = NAN, hum = NAN;
    if (!readDHT(temp, hum)) {
      Serial.println("Falha: não foi possível ler DHT após retries.");
      failCount++;
      return;
    }

    // atualiza latest (para endpoint /status)
    latestTemp = temp;
    latestHum  = hum;

    Serial.printf("Leitura -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);

    // decide se grava no DB (comparar com lastSent)
    bool shouldSend = false;
    if (isnan(lastSentTemp) || isnan(lastSentHum)) {
      // primeira vez: enviar para preencher DB
      shouldSend = true;
      Serial.println("Primeiro envio: gravando no DB.");
    } else {
      float dt = fabs(temp - lastSentTemp);
      float dh = fabs(hum  - lastSentHum);
      Serial.printf("Diferença p/ ultimo salvo -> dT=%.2f, dH=%.2f\n", dt, dh);
      if (dt >= TEMP_THRESHOLD || dh >= HUM_THRESHOLD) {
        shouldSend = true;
        Serial.println("Diferença maior que threshold: gravando no DB.");
      } else {
        Serial.println("Diferença menor que threshold: NÃO gravar no DB, apenas atualizar /status.");
      }
    }

    if (shouldSend) {
      bool ok = sendToServer(temp, hum);
      if (ok) {
        lastSentTemp = temp;
        lastSentHum  = hum;
        Serial.println("Envio OK e atualizado lastSent.");
        failCount = 0;
      } else {
        Serial.println("Envio falhou.");
        failCount++;
      }
    } else {
      // não enviar ao DB; apenas mantém latestTemp/latestHum para UI
    }
  }

  // pequeno delay para liberar CPU (não bloquear demais)
  delay(10);
}
